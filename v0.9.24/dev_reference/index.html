<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · JuliaInterpreter.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">JuliaInterpreter.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../ast/">Lowered representation</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li class="is-active"><a class="tocitem" href>Function reference</a><ul class="internal"><li><a class="tocitem" href="#Running-the-interpreter"><span>Running the interpreter</span></a></li><li><a class="tocitem" href="#Frame-creation"><span>Frame creation</span></a></li><li><a class="tocitem" href="#Frame-traversal"><span>Frame traversal</span></a></li><li><a class="tocitem" href="#Frame-execution"><span>Frame execution</span></a></li><li><a class="tocitem" href="#Breakpoints"><span>Breakpoints</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Internal-storage"><span>Internal storage</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Hooks"><span>Hooks</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/master/docs/src/dev_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-reference"><a class="docs-heading-anchor" href="#Function-reference">Function reference</a><a id="Function-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-reference" title="Permalink"></a></h1><h2 id="Running-the-interpreter"><a class="docs-heading-anchor" href="#Running-the-interpreter">Running the interpreter</a><a id="Running-the-interpreter-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-interpreter" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.@interpret" href="#JuliaInterpreter.@interpret"><code>JuliaInterpreter.@interpret</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@interpret f(args; kwargs...)</code></pre><p>Evaluate <code>f</code> on the specified arguments using the interpreter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [1, 7]
2-element Vector{Int64}:
 1
 7

julia&gt; sum(a)
8

julia&gt; @interpret sum(a)
8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L724-L743">source</a></section></article><h2 id="Frame-creation"><a class="docs-heading-anchor" href="#Frame-creation">Frame creation</a><a id="Frame-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Frame-creation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.Frame-Tuple{Module, Expr}" href="#JuliaInterpreter.Frame-Tuple{Module, Expr}"><code>JuliaInterpreter.Frame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frame = Frame(mod::Module, ex::Expr)</code></pre><p>Construct a <code>Frame</code> to evaluate <code>ex</code> in module <code>mod</code>.</p><p>This constructor can error, for example if lowering <code>ex</code> results in an <code>:error</code> or <code>:incomplete</code> expression, or if it otherwise fails to return a <code>:thunk</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L269-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.ExprSplitter" href="#JuliaInterpreter.ExprSplitter"><code>JuliaInterpreter.ExprSplitter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExprSplitter(mod::Module, ex::Expr; lnn=nothing)</code></pre><p>Create an iterable that returns individual expressions together with their module of evaluation. Optionally supply an initial <code>LineNumberNode</code> <code>lnn</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; expr = quote
           public(x::Integer) = true
           module Private
           private(y::String) = false
           end
           const threshold = 0.1
       end;

julia&gt; for (mod, ex) in ExprSplitter(Main, expr)
           @show mod ex
       end
mod = Main
ex = quote
    #= REPL[7]:2 =#
    public(x::Integer) = begin
            #= REPL[7]:2 =#
            true
        end
end
mod = Main.Private
ex = quote
    #= REPL[7]:4 =#
    private(y::String) = begin
            #= REPL[7]:4 =#
            false
        end
end
mod = Main
ex = :($(Expr(:toplevel, :(()), :(const threshold = 0.1))))</code></pre><p>Note that <code>Main.Private</code> was created for you so that its internal expressions could be evaluated. <code>ExprSplitter</code> will check to see whether the module already exists and if so return it rather than try to create a new module with the same name.</p><p>In general each returned expression is a block with two parts: a <code>LineNumberNode</code> followed by a single expression. In some cases the returned expression may be <code>:toplevel</code>, as shown in the <code>const</code> declaration, but otherwise it will be a <code>:block</code>.</p><p><strong>World age, frame creation, and evaluation</strong></p><p>The primary purpose of <code>ExprSplitter</code> is to allow sequential return to top-level (e.g., the REPL) after evaluation of each expression. Returning to top-level allows the world age to update, and hence allows one to call methods and use types defined in earlier expressions in a block.</p><p>For evaluation by JuliaInterpreter, the returned module/expression pairs can be passed directly to the <code>Frame</code> constructor. However, some expressions cannot be converted into <code>Frame</code>s and may need special handling:</p><pre><code class="language-julia hljs">julia&gt; for (mod, ex) in ExprSplitter(Main, expr)
           if ex.head === :global
               # global declarations can&#39;t be lowered to a CodeInfo.
               # In this demo we choose to evaluate them, but you can do something else.
               Core.eval(mod, ex)
               continue
           end
           frame = Frame(mod, ex)
           debug_command(frame, :c, true)
       end

julia&gt; threshold
0.1

julia&gt; public(3)
true</code></pre><p>If you&#39;re parsing package code, <code>ex</code> might be a docstring-expression; you may wish to check for such expressions and take distinct actions.</p><p>See <a href="#JuliaInterpreter.Frame-Tuple{Module, Expr}"><code>Frame(mod::Module, ex::Expr)</code></a> for more information about frame creation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L341-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.enter_call" href="#JuliaInterpreter.enter_call"><code>JuliaInterpreter.enter_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frame = enter_call(f, args...; kwargs...)</code></pre><p>Build a <code>Frame</code> ready to execute <code>f</code> with the specified positional and keyword arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call(mymethod, 1)
Frame for mymethod(x) @ Main none:1
  1* 1  1 ─ %1 = x + 1
  2  1  └──      return %1
x = 1

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.enter_call(mymethod, [1.0, 2.0])
Frame for mymethod(x::Vector{T}) where T @ Main none:1
  1* 1  1 ─     return 1
x = [1.0, 2.0]
T = Float64</code></pre><p>For a <code>@generated</code> function you can use <code>enter_call((f, true), args...; kwargs...)</code> to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p>See <a href="#JuliaInterpreter.enter_call_expr"><code>enter_call_expr</code></a> for a similar approach based on expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L626-L658">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.enter_call_expr" href="#JuliaInterpreter.enter_call_expr"><code>JuliaInterpreter.enter_call_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frame = enter_call_expr(expr; enter_generated=false)</code></pre><p>Build a <code>Frame</code> ready to execute the expression <code>expr</code>. Set <code>enter_generated=true</code> if you want to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod(1)))
Frame for mymethod(x) @ Main none:1
  1* 1  1 ─ %1 = x + 1
  2  1  └──      return %1
x = 1

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; a = [1.0, 2.0]
2-element Vector{Float64}:
 1.0
 2.0

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod($a)))
Frame for mymethod(x::Vector{T}) where T @ Main none:1
  1* 1  1 ─     return 1
x = [1.0, 2.0]
T = Float64</code></pre><p>See <a href="#JuliaInterpreter.enter_call"><code>enter_call</code></a> for a similar approach not based on expressions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L581-L616">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.prepare_frame" href="#JuliaInterpreter.prepare_frame"><code>JuliaInterpreter.prepare_frame</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frame = prepare_frame(framecode::FrameCode, frameargs, lenv)</code></pre><p>Construct a new <code>Frame</code> for <code>framecode</code>, given lowered-code arguments <code>frameargs</code> and static parameters <code>lenv</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about how to prepare the inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L323-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.determine_method_for_expr" href="#JuliaInterpreter.determine_method_for_expr"><code>JuliaInterpreter.determine_method_for_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">framecode, frameargs, lenv, argtypes = determine_method_for_expr(expr; enter_generated = false)</code></pre><p>Prepare all the information needed to execute a particular <code>:call</code> expression <code>expr</code>. For example, try <code>JuliaInterpreter.determine_method_for_expr(:($sum([1,2])))</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about the outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L562-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.prepare_args" href="#JuliaInterpreter.prepare_args"><code>JuliaInterpreter.prepare_args</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frun, allargs = prepare_args(fcall, fargs, kwargs)</code></pre><p>Prepare the complete argument sequence for a call to <code>fcall</code>. <code>fargs = [fcall, args...]</code> is a list containing both <code>fcall</code> (the <code>#self#</code> slot in lowered code) and the positional arguments supplied to <code>fcall</code>. <code>kwargs</code> is a list of keyword arguments, supplied either as list of expressions <code>:(kwname=kwval)</code> or pairs <code>:kwname=&gt;kwval</code>.</p><p>For non-keyword methods, <code>frun === fcall</code>, but for methods with keywords <code>frun</code> will be the keyword-sorter function for <code>fcall</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mymethod(x) = 1
mymethod (generic function with 1 method)

julia&gt; mymethod(x, y; verbose=false) = nothing
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 15], ())
(mymethod, Any[mymethod, 15])

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 1, 2], [:verbose=&gt;true])
(Core.kwcall, Any[Core.kwcall, (verbose = true,), mymethod, 1, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L105-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.prepare_call" href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">framecode, frameargs, lenv, argtypes = prepare_call(f, allargs; enter_generated=false)</code></pre><p>Prepare all the information needed to execute lowered code for <code>f</code> given arguments <code>allargs</code>. <code>f</code> and <code>allargs</code> are the outputs of <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>. For <code>@generated</code> methods, set <code>enter_generated=true</code> if you want to extract the lowered code of the generator itself.</p><p>On return <code>framecode</code> is the <a href="#JuliaInterpreter.FrameCode"><code>FrameCode</code></a> of the method. <code>frameargs</code> contains the actual arguments needed for executing this frame (for generators, this will be the types of <code>allargs</code>); <code>lenv</code> is the &quot;environment&quot;, i.e., the static parameters for <code>f</code> given <code>allargs</code>. <code>argtypes</code> is the <code>Tuple</code>-type for this specific call (equivalent to the signature of the <code>MethodInstance</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 1 method)

julia&gt; framecode, frameargs, lenv, argtypes = JuliaInterpreter.prepare_call(mymethod, [mymethod, [1.0,2.0]]);

julia&gt; framecode
  1  1  1 ─     return 1

julia&gt; frameargs
2-element Vector{Any}:
 mymethod (generic function with 1 method)
 [1.0, 2.0]

julia&gt; lenv
svec(Float64)

julia&gt; argtypes
Tuple{typeof(mymethod), Vector{Float64}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L201-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.get_call_framecode" href="#JuliaInterpreter.get_call_framecode"><code>JuliaInterpreter.get_call_framecode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">framecode, lenv = get_call_framecode(fargs, parentframe::FrameCode, idx::Int)</code></pre><p>Return the framecode and environment for a call specified by <code>fargs = [f, args...]</code> (see <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>). <code>parentframecode</code> is the caller, and <code>idx</code> is the program-counter index. If possible, <code>framecode</code> will be looked up from the local method tables of <code>parentframe</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/localmethtable.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.optimize!" href="#JuliaInterpreter.optimize!"><code>JuliaInterpreter.optimize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">optimize!(code::CodeInfo, mod::Module)</code></pre><p>Perform minor optimizations on the lowered AST in <code>code</code> to reduce execution time of the interpreter. Currently it looks up <code>GlobalRef</code>s (for which it needs <code>mod</code> to know the scope in which this will run) and ensures that no statement includes nested <code>:call</code> expressions (splitting them out into multiple SSA-form statements if needed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/optimize.jl#L147-L155">source</a></section></article><h2 id="Frame-traversal"><a class="docs-heading-anchor" href="#Frame-traversal">Frame traversal</a><a id="Frame-traversal-1"></a><a class="docs-heading-anchor-permalink" href="#Frame-traversal" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.root" href="#JuliaInterpreter.root"><code>JuliaInterpreter.root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rframe = root(frame)</code></pre><p>Return the initial frame in the call stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L296-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.leaf" href="#JuliaInterpreter.leaf"><code>JuliaInterpreter.leaf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lframe = leaf(frame)</code></pre><p>Return the deepest callee in the call stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L303-L307">source</a></section></article><h2 id="Frame-execution"><a class="docs-heading-anchor" href="#Frame-execution">Frame execution</a><a id="Frame-execution-1"></a><a class="docs-heading-anchor-permalink" href="#Frame-execution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.Compiled" href="#JuliaInterpreter.Compiled"><code>JuliaInterpreter.Compiled</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Compiled</code> is a trait indicating that any <code>:call</code> expressions should be evaluated using Julia&#39;s normal compiled-code evaluation. The alternative is to pass <code>stack=Frame[]</code>, which will cause all calls to be evaluated via the interpreter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.step_expr!" href="#JuliaInterpreter.step_expr!"><code>JuliaInterpreter.step_expr!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = step_expr!(recurse, frame, istoplevel=false)
pc = step_expr!(frame, istoplevel=false)</code></pre><p>Execute the next statement in <code>frame</code>. <code>pc</code> is the new program counter, or <code>nothing</code> if execution terminates, or a <a href="#JuliaInterpreter.BreakpointRef"><code>BreakpointRef</code></a> if execution hits a breakpoint.</p><p><code>recurse</code> controls call evaluation; <code>recurse = Compiled()</code> evaluates :call expressions by normal dispatch. The default value <code>recurse = finish_and_return!</code> will use recursive interpretation.</p><p>If you are evaluating <code>frame</code> at module scope you should pass <code>istoplevel=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/interpret.jl#L584-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.finish!" href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = finish!(recurse, frame, istoplevel=false)
pc = finish!(frame, istoplevel=false)</code></pre><p>Run <code>frame</code> until execution terminates. <code>pc</code> is either <code>nothing</code> (if execution terminates when it hits a <code>return</code> statement) or a reference to a breakpoint. In the latter case, <code>leaf(frame)</code> returns the frame in which it hit the breakpoint.</p><p><code>recurse</code> controls call evaluation; <code>recurse = Compiled()</code> evaluates :call expressions by normal dispatch, whereas the default <code>recurse = finish_and_return!</code> uses recursive interpretation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.finish_and_return!" href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = finish_and_return!(recurse, frame, istoplevel::Bool=false)
ret = finish_and_return!(frame, istoplevel::Bool=false)</code></pre><p>Call <a href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a> and pass back the return value <code>ret</code>. If execution pauses at a breakpoint, <code>ret</code> is the reference to the breakpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.finish_stack!" href="#JuliaInterpreter.finish_stack!"><code>JuliaInterpreter.finish_stack!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = finish_stack!(recurse, frame, rootistoplevel=false)
ret = finish_stack!(frame, rootistoplevel=false)</code></pre><p>Unwind the callees of <code>frame</code>, finishing each before returning to the caller. <code>frame</code> itself is also finished. <code>rootistoplevel</code> should be true if the root frame is top-level.</p><p><code>ret</code> is typically the returned value. If execution hits a breakpoint, <code>ret</code> will be a reference to the breakpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.get_return" href="#JuliaInterpreter.get_return"><code>JuliaInterpreter.get_return</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = get_return(frame)</code></pre><p>Get the return value of <code>frame</code>. Throws an error if <code>frame.pc</code> does not point to a <code>return</code> expression. <code>frame</code> must have already been executed so that the return value has been computed (see, e.g., <a href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/interpret.jl#L646-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.next_until!" href="#JuliaInterpreter.next_until!"><code>JuliaInterpreter.next_until!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = next_until!(predicate, recurse, frame, istoplevel=false)
pc = next_until!(predicate, frame, istoplevel=false)</code></pre><p>Execute the current statement. Then step through statements of <code>frame</code> until the next statement satisfies <code>predicate(frame)</code>. <code>pc</code> will be the index of the statement at which evaluation terminates, <code>nothing</code> (if the frame reached a <code>return</code>), or a <code>BreakpointRef</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.maybe_next_until!" href="#JuliaInterpreter.maybe_next_until!"><code>JuliaInterpreter.maybe_next_until!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = maybe_next_until!(predicate, recurse, frame, istoplevel=false)
pc = maybe_next_until!(predicate, frame, istoplevel=false)</code></pre><p>Like <a href="#JuliaInterpreter.next_until!"><code>next_until!</code></a> except checks <code>predicate</code> before executing the current statment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.through_methoddef_or_done!" href="#JuliaInterpreter.through_methoddef_or_done!"><code>JuliaInterpreter.through_methoddef_or_done!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = through_methoddef_or_done!(recurse, frame)
pc = through_methoddef_or_done!(frame)</code></pre><p>Runs <code>frame</code> at top level until it either finishes (e.g., hits a <code>return</code> statement) or defines a new method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L139-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.evaluate_call!" href="#JuliaInterpreter.evaluate_call!"><code>JuliaInterpreter.evaluate_call!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = evaluate_call!(Compiled(), frame::Frame, call_expr)
ret = evaluate_call!(recurse,    frame::Frame, call_expr)</code></pre><p>Evaluate a <code>:call</code> expression <code>call_expr</code> in the context of <code>frame</code>. The first causes it to be executed using Julia&#39;s normal dispatch (compiled code), whereas the second recurses in via the interpreter. <code>recurse</code> has a default value of <a href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/interpret.jl#L270-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.evaluate_foreigncall" href="#JuliaInterpreter.evaluate_foreigncall"><code>JuliaInterpreter.evaluate_foreigncall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = evaluate_foreigncall(recurse, frame::Frame, call_expr)</code></pre><p>Evaluate a <code>:foreigncall</code> (from a <code>ccall</code>) statement <code>callexpr</code> in the context of <code>frame</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/interpret.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.maybe_evaluate_builtin" href="#JuliaInterpreter.maybe_evaluate_builtin"><code>JuliaInterpreter.maybe_evaluate_builtin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = maybe_evaluate_builtin(frame, call_expr, expand::Bool)</code></pre><p>If <code>call_expr</code> is to a builtin function, evaluate it, returning the result inside a <code>Some</code> wrapper. Otherwise, return <code>call_expr</code>.</p><p>If <code>expand</code> is true, <code>Core._apply_iterate</code> calls will be resolved as a call to the applied function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/builtins.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.next_call!" href="#JuliaInterpreter.next_call!"><code>JuliaInterpreter.next_call!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = next_call!(recurse, frame, istoplevel=false)
pc = next_call!(frame, istoplevel=false)</code></pre><p>Execute the current statement. Continue stepping through <code>frame</code> until the next <code>:return</code> or <code>:call</code> expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.maybe_next_call!" href="#JuliaInterpreter.maybe_next_call!"><code>JuliaInterpreter.maybe_next_call!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = maybe_next_call!(recurse, frame, istoplevel=false)
pc = maybe_next_call!(frame, istoplevel=false)</code></pre><p>Return the current program counter of <code>frame</code> if it is a <code>:return</code> or <code>:call</code> expression. Otherwise, step through the statements of <code>frame</code> until the next <code>:return</code> or <code>:call</code> expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.next_line!" href="#JuliaInterpreter.next_line!"><code>JuliaInterpreter.next_line!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = next_line!(recurse, frame, istoplevel=false)
pc = next_line!(frame, istoplevel=false)</code></pre><p>Execute until reaching the first call of the next line of the source code. Upon return, <code>pc</code> is either the new program counter, <code>nothing</code> if a <code>return</code> is reached, or a <code>BreakpointRef</code> if it encountered a wrapper call. In the latter case, call <code>leaf(frame)</code> to obtain the new execution frame.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L161-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.until_line!" href="#JuliaInterpreter.until_line!"><code>JuliaInterpreter.until_line!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pc = until_line!(recurse, frame, line=nothing istoplevel=false)
pc = until_line!(frame, line=nothing, istoplevel=false)</code></pre><p>Execute until the current frame reaches a line greater than <code>line</code>. If <code>line == nothing</code> execute until the current frame reaches any line greater than the current line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L188-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.maybe_reset_frame!" href="#JuliaInterpreter.maybe_reset_frame!"><code>JuliaInterpreter.maybe_reset_frame!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = maybe_reset_frame!(recurse, frame, pc, rootistoplevel)</code></pre><p>Perform a return to the caller, or descend to the level of a breakpoint. <code>pc</code> is the return state from the previous command (e.g., <code>next_call!</code> or similar). <code>rootistoplevel</code> should be true if the root frame is top-level.</p><p><code>ret</code> will be <code>nothing</code> if we have just completed a top-level frame. Otherwise,</p><pre><code class="nohighlight hljs">cframe, cpc = ret</code></pre><p>where <code>cframe</code> is the frame from which execution should continue and <code>cpc</code> is the state of <code>cframe</code> (the program counter, a <code>BreakpointRef</code>, or <code>nothing</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L351-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.maybe_step_through_wrapper!" href="#JuliaInterpreter.maybe_step_through_wrapper!"><code>JuliaInterpreter.maybe_step_through_wrapper!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cframe = maybe_step_through_wrapper!(recurse, frame)
cframe = maybe_step_through_wrapper!(frame)</code></pre><p>Return the new frame of execution, potentially stepping through &quot;wrapper&quot; methods like those that supply default positional arguments or handle keywords. <code>cframe</code> is the leaf frame from which execution should start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L207-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.maybe_step_through_kwprep!" href="#JuliaInterpreter.maybe_step_through_kwprep!"><code>JuliaInterpreter.maybe_step_through_kwprep!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frame = maybe_step_through_kwprep!(recurse, frame)
frame = maybe_step_through_kwprep!(frame)</code></pre><p>If <code>frame.pc</code> points to the beginning of preparatory work for calling a keyword-argument function, advance forward until the actual call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L266-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.handle_err" href="#JuliaInterpreter.handle_err"><code>JuliaInterpreter.handle_err</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loc = handle_err(recurse, frame, err)</code></pre><p>Deal with an error <code>err</code> that arose while evaluating <code>frame</code>. There are one of three behaviors:</p><ul><li>if <code>frame</code> catches the error, <code>loc</code> is the program counter at which to resume evaluation of <code>frame</code>;</li><li>if <code>frame</code> doesn&#39;t catch the error, but <code>break_on_error[]</code> is <code>true</code>, <code>loc</code> is a <code>BreakpointRef</code>;</li><li>otherwise, <code>err</code> gets rethrown.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/interpret.jl#L602-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.debug_command" href="#JuliaInterpreter.debug_command"><code>JuliaInterpreter.debug_command</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ret = debug_command(recurse, frame, cmd, rootistoplevel=false; line=nothing)
ret = debug_command(frame, cmd, rootistoplevel=false; line=nothing)</code></pre><p>Perform one &quot;debugger&quot; command. The keyword arguments are not used for all debug commands. <code>cmd</code> should be one of:</p><ul><li><code>:n</code>: advance to the next line</li><li><code>:s</code>: step into the next call</li><li><code>:sl</code> step into the last call on the current line (e.g. steps into <code>f</code> if the line is <code>f(g(h(x)))</code>).</li><li><code>:sr</code> step until the current function will return</li><li><code>:until</code>: advance the frame to line <code>line</code> if given, otherwise advance to the line after the current line</li><li><code>:c</code>: continue execution until termination or reaching a breakpoint</li><li><code>:finish</code>: finish the current frame and return to the parent</li></ul><p>or one of the &#39;advanced&#39; commands</p><ul><li><code>:nc</code>: step forward to the next call</li><li><code>:se</code>: execute a single statement</li><li><code>:si</code>: execute a single statement, stepping in if it&#39;s a call</li><li><code>:sg</code>: step into the generator of a generated function</li></ul><p><code>rootistoplevel</code> and <code>ret</code> are as described for <a href="#JuliaInterpreter.maybe_reset_frame!"><code>JuliaInterpreter.maybe_reset_frame!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L424-L447">source</a></section></article><h2 id="Breakpoints"><a class="docs-heading-anchor" href="#Breakpoints">Breakpoints</a><a id="Breakpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Breakpoints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.@breakpoint" href="#JuliaInterpreter.@breakpoint"><code>JuliaInterpreter.@breakpoint</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@breakpoint f(args...) condition=nothing
@breakpoint f(args...) line condition=nothing</code></pre><p>Break upon entry, or at the specified line number, in the method called by <code>f(args...)</code>. Optionally supply a condition expressed in terms of the arguments and internal variables of the method. If <code>line</code> is supplied, it must be a literal integer.</p><p><strong>Example</strong></p><p>Suppose a method <code>mysum</code> is defined as follows, where the numbers to the left are the line number in the file:</p><pre><code class="nohighlight hljs">12 function mysum(A)
13     s = zero(eltype(A))
14     for a in A
15         s += a
16     end
17     return s
18 end</code></pre><p>Then</p><pre><code class="nohighlight hljs">@breakpoint mysum(A) 15 s&gt;10</code></pre><p>would cause execution of the loop to break whenever <code>s&gt;10</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L371-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.@bp" href="#JuliaInterpreter.@bp"><code>JuliaInterpreter.@bp</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@bp</code></pre><p>Insert a breakpoint at a location in the source code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L431-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.breakpoint" href="#JuliaInterpreter.breakpoint"><code>JuliaInterpreter.breakpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">breakpoint(f, [sig], [line], [condition])</code></pre><p>Add a breakpoint to <code>f</code> with the specified argument types <code>sig</code>.¨ If <code>sig</code> is not given, the breakpoint will apply to all methods of <code>f</code>. If <code>f</code> is a method, the breakpoint will only apply to that method. Optionally specify an absolute line number <code>line</code> in the source file; the default is to break upon entry at the first line of the body. Without <code>condition</code>, the breakpoint will be triggered every time it is encountered; the second only if <code>condition</code> evaluates to <code>true</code>. <code>condition</code> should be written in terms of the arguments and local variables of <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">function radius2(x, y)
    return x^2 + y^2
end

breakpoint(radius2, Tuple{Int,Int}, :(y &gt; x))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L107-L127">source</a></section><section><div><pre><code class="nohighlight hljs">breakpoint(file, line, [condition])</code></pre><p>Set a breakpoint in <code>file</code> at <code>line</code>. The argument <code>file</code> can be a filename, a partial path or absolute path. For example, <code>file = foo.jl</code> will match against all files with the name <code>foo.jl</code>, <code>file = src/foo.jl</code> will match against all paths containing <code>src/foo.jl</code>, e.g. both <code>Foo/src/foo.jl</code> and <code>Bar/src/foo.jl</code>. Absolute paths only matches against the file with that exact absolute path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L151-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.enable" href="#JuliaInterpreter.enable"><code>JuliaInterpreter.enable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">enable(bp::AbstractBreakpoint)</code></pre><p>Enable breakpoint <code>bp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L261-L265">source</a></section><section><div><pre><code class="nohighlight hljs">enable()</code></pre><p>Enable all breakpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.disable" href="#JuliaInterpreter.disable"><code>JuliaInterpreter.disable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disable(bp::AbstractBreakpoint)</code></pre><p>Disable breakpoint <code>bp</code>. Disabled breakpoints can be re-enabled with <a href="#JuliaInterpreter.enable"><code>enable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L270-L274">source</a></section><section><div><pre><code class="nohighlight hljs">disable()</code></pre><p>Disable all breakpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.remove" href="#JuliaInterpreter.remove"><code>JuliaInterpreter.remove</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove(bp::AbstractBreakpoint)</code></pre><p>Remove (delete) breakpoint <code>bp</code>. Removed breakpoints cannot be re-enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L278-L282">source</a></section><section><div><pre><code class="nohighlight hljs">remove()</code></pre><p>Remove all breakpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.toggle" href="#JuliaInterpreter.toggle"><code>JuliaInterpreter.toggle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toggle(bp::AbstractBreakpoint)</code></pre><p>Toggle breakpoint <code>bp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.break_on" href="#JuliaInterpreter.break_on"><code>JuliaInterpreter.break_on</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">break_on(states...)</code></pre><p>Turn on automatic breakpoints when any of the conditions described in <code>states</code> occurs. The supported states are:</p><ul><li><code>:error</code>: trigger a breakpoint any time an uncaught exception is thrown</li><li><code>:throw</code> : trigger a breakpoint any time a throw is executed (even if it will eventually be caught)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L331-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.break_off" href="#JuliaInterpreter.break_off"><code>JuliaInterpreter.break_off</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">break_off(states...)</code></pre><p>Turn off automatic breakpoints when any of the conditions described in <code>states</code> occurs. See <a href="#JuliaInterpreter.break_on"><code>break_on</code></a> for a description of valid states.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L352-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.breakpoints" href="#JuliaInterpreter.breakpoints"><code>JuliaInterpreter.breakpoints</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">breakpoints()::Vector{AbstractBreakpoint}</code></pre><p>Return an array with all breakpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.dummy_breakpoint" href="#JuliaInterpreter.dummy_breakpoint"><code>JuliaInterpreter.dummy_breakpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bpref = dummy_breakpoint(recurse, frame::Frame, istoplevel)</code></pre><p>Return a fake breakpoint. <code>dummy_breakpoint</code> can be useful as the <code>recurse</code> argument to <code>evaluate_call!</code> (or any of the higher-order commands) to ensure that you return immediately after stepping into a call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/commands.jl#L36-L42">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.Frame" href="#JuliaInterpreter.Frame"><code>JuliaInterpreter.Frame</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Frame</code> represents the current execution state in a particular call frame. Fields:</p><ul><li><code>framecode</code>: the <a href="#JuliaInterpreter.FrameCode"><code>FrameCode</code></a> for this frame.</li><li><code>framedata</code>: the <a href="#JuliaInterpreter.FrameData"><code>FrameData</code></a> for this frame.</li><li><code>pc</code>: the program counter (integer index of the next statment to be evaluated) for this frame.</li><li><code>caller</code>: the parent caller of this frame, or <code>nothing</code>.</li><li><code>callee</code>: the frame called by this one, or <code>nothing</code>.</li></ul><p>The <code>Base</code> functions <code>show_backtrace</code> and <code>display_error</code> are overloaded such that <code>show_backtrace(io::IO, frame::Frame)</code> and <code>display_error(io::IO, er, frame::Frame)</code> shows a backtrace or error, respectively, in a similar way as to how Base shows them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L222-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.FrameCode" href="#JuliaInterpreter.FrameCode"><code>JuliaInterpreter.FrameCode</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FrameCode</code> holds static information about a method or toplevel code. One <code>FrameCode</code> can be shared by many calling <code>Frame</code>s.</p><p>Important fields:</p><ul><li><code>scope</code>: the <code>Method</code> or <code>Module</code> in which this frame is to be evaluated.</li><li><code>src</code>: the <code>CodeInfo</code> object storing (optimized) lowered source code.</li><li><code>methodtables</code>: a vector, each entry potentially stores a &quot;local method table&quot; for the corresponding <code>:call</code> expression in <code>src</code> (undefined entries correspond to statements that do not contain <code>:call</code> expressions).</li><li><code>used</code>: a <code>BitSet</code> storing the list of SSAValues that get referenced by later statements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L79-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.FrameData" href="#JuliaInterpreter.FrameData"><code>JuliaInterpreter.FrameData</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FrameData</code> holds the arguments, local variables, and intermediate execution state in a particular call frame.</p><p>Important fields:</p><ul><li><code>locals</code>: a vector containing the input arguments and named local variables for this frame. The indexing corresponds to the names in the <code>slotnames</code> of the src. Use <a href="#JuliaInterpreter.locals"><code>locals</code></a> to extract the current value of local variables.</li><li><code>ssavalues</code>: a vector containing the <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment</a> values produced at the current state of execution.</li><li><code>sparams</code>: the static type parameters, e.g., for <code>f(x::Vector{T}) where T</code> this would store the value of <code>T</code> given the particular input <code>x</code>.</li><li><code>exception_frames</code>: a list of indexes to <code>catch</code> blocks for handling exceptions within the current frame. The active handler is the last one on the list.</li><li><code>last_exception</code>: the exception <code>throw</code>n by this frame or one of its callees.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L185-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter._INACTIVE_EXCEPTION" href="#JuliaInterpreter._INACTIVE_EXCEPTION"><code>JuliaInterpreter._INACTIVE_EXCEPTION</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">_INACTIVE_EXCEPTION</code></pre><p>Represents a case where no exceptions are thrown yet. End users will not see this singleton type, otherwise it usually means there is missing error handling in the interpretation process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L213-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.FrameInstance" href="#JuliaInterpreter.FrameInstance"><code>JuliaInterpreter.FrameInstance</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>FrameInstance</code> represents a method specialized for particular argument types.</p><p>Fields:</p><ul><li><code>framecode</code>: the <a href="#JuliaInterpreter.FrameCode"><code>FrameCode</code></a> for the method.</li><li><code>sparam_vals</code>: the static parameter values for the method.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.BreakpointState" href="#JuliaInterpreter.BreakpointState"><code>JuliaInterpreter.BreakpointState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BreakpointState(isactive=true, condition=JuliaInterpreter.truecondition)</code></pre><p><code>BreakpointState</code> represents a breakpoint at a particular statement in a <code>FrameCode</code>. <code>isactive</code> indicates whether the breakpoint is currently <a href="#JuliaInterpreter.enable"><code>enable</code></a>d or <a href="#JuliaInterpreter.disable"><code>disable</code></a>d. <code>condition</code> is a function that accepts a single <code>Frame</code>, and <code>condition(frame)</code> must return either <code>true</code> or <code>false</code>. Execution will stop at a breakpoint only if <code>isactive</code> and <code>condition(frame)</code> both evaluate as <code>true</code>. The default <code>condition</code> always returns <code>true</code>.</p><p>To create these objects, see <a href="#JuliaInterpreter.breakpoint"><code>breakpoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.BreakpointRef" href="#JuliaInterpreter.BreakpointRef"><code>JuliaInterpreter.BreakpointRef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BreakpointRef(framecode, stmtidx)
BreakpointRef(framecode, stmtidx, err)</code></pre><p>A reference to a breakpoint at a particular statement index <code>stmtidx</code> in <code>framecode</code>. If the break was due to an error, supply that as well.</p><p>Commands that execute complex control-flow (e.g., <code>next_line!</code>) may also return a <code>BreakpointRef</code> to indicate that the execution stack switched frames, even when no breakpoint has been set at the corresponding statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L356-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.AbstractBreakpoint" href="#JuliaInterpreter.AbstractBreakpoint"><code>JuliaInterpreter.AbstractBreakpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>AbstractBreakpoint</code> is the abstract type that is the supertype for breakpoints. Currently, the concrete breakpoint types <a href="#JuliaInterpreter.BreakpointSignature"><code>BreakpointSignature</code></a> and <a href="#JuliaInterpreter.BreakpointFileLocation"><code>BreakpointFileLocation</code></a> exist.</p><p>Common fields shared by the concrete breakpoints:</p><ul><li><code>condition::Union{Nothing,Expr,Tuple{Module,Expr}}</code>: the condition when the breakpoint applies . <code>nothing</code> means unconditionally, otherwise when the <code>Expr</code> (optionally in <code>Module</code>).</li><li><code>enabled::Ref{Bool}</code>: If the breakpoint is enabled (should not be directly modified, use <a href="#JuliaInterpreter.enable"><code>enable()</code></a> or <a href="#JuliaInterpreter.disable"><code>disable()</code></a>).</li><li><code>instances::Vector{BreakpointRef}</code>: All the <a href="#JuliaInterpreter.BreakpointRef"><code>BreakpointRef</code></a> that the breakpoint has applied to.</li><li><code>line::Int</code> The line of the breakpoint (equal to 0 if unset).</li></ul><p>See <a href="#JuliaInterpreter.BreakpointSignature"><code>BreakpointSignature</code></a> and <a href="#JuliaInterpreter.BreakpointFileLocation"><code>BreakpointFileLocation</code></a> for additional fields in the concrete types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L393-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.BreakpointSignature" href="#JuliaInterpreter.BreakpointSignature"><code>JuliaInterpreter.BreakpointSignature</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>BreakpointSignature</code> is a breakpoint that is set on methods or functions.</p><p>Fields:</p><ul><li><code>f::Union{Method, Function, Type}</code>: A method or function that the breakpoint should apply to.</li><li><code>sig::Union{Nothing, Type}</code>: if <code>f</code> is a <code>Method</code>, always equal to <code>nothing</code>. Otherwise, contains the method signature  as a tuple type for what methods the breakpoint should apply to.</li></ul><p>For common fields shared by all breakpoints, see <a href="#JuliaInterpreter.AbstractBreakpoint"><code>AbstractBreakpoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L423-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.BreakpointFileLocation" href="#JuliaInterpreter.BreakpointFileLocation"><code>JuliaInterpreter.BreakpointFileLocation</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>BreakpointFileLocation</code> is a breakpoint that is set on a line in a file.</p><p>Fields:</p><ul><li><code>path::String</code>: The literal string that was used to create the breakpoint, e.g. <code>&quot;path/file.jl&quot;</code>.</li><li><code>abspath</code>::String: The absolute path to the file when the breakpoint was created, e.g. <code>&quot;/Users/Someone/path/file.jl&quot;</code>.</li></ul><p>For common fields shared by all breakpoints, see <a href="#JuliaInterpreter.AbstractBreakpoint"><code>AbstractBreakpoint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L459-L467">source</a></section></article><h2 id="Internal-storage"><a class="docs-heading-anchor" href="#Internal-storage">Internal storage</a><a id="Internal-storage-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-storage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.framedict" href="#JuliaInterpreter.framedict"><code>JuliaInterpreter.framedict</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>framedict[method]</code> returns the <code>FrameCode</code> for <code>method</code>. For <code>@generated</code> methods, see <a href="#JuliaInterpreter.genframedict"><code>genframedict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.genframedict" href="#JuliaInterpreter.genframedict"><code>JuliaInterpreter.genframedict</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>genframedict[(method,argtypes)]</code> returns the <code>FrameCode</code> for a <code>@generated</code> method <code>method</code>, for the particular argument types <code>argtypes</code>.</p><p>The framecodes stored in <code>genframedict</code> are for the code returned by the generator (i.e, what will run when you call the method on particular argument types); for the generator itself, its framecode would be stored in <a href="#JuliaInterpreter.framedict"><code>framedict</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.compiled_methods" href="#JuliaInterpreter.compiled_methods"><code>JuliaInterpreter.compiled_methods</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>meth ∈ compiled_methods</code> indicates that <code>meth</code> should be run using <a href="#JuliaInterpreter.Compiled"><code>Compiled</code></a> rather than recursed into via the interpreter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.compiled_modules" href="#JuliaInterpreter.compiled_modules"><code>JuliaInterpreter.compiled_modules</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>mod ∈ compiled_modules</code> indicates that any method in <code>mod</code> should be run using <a href="#JuliaInterpreter.Compiled"><code>Compiled</code></a> rather than recursed into via the interpreter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.interpreted_methods" href="#JuliaInterpreter.interpreted_methods"><code>JuliaInterpreter.interpreted_methods</code></a> — <span class="docstring-category">Constant</span></header><section><div><p><code>meth ∈ interpreted_methods</code> indicates that <code>meth</code> should <em>not</em> be run using <a href="#JuliaInterpreter.Compiled"><code>Compiled</code></a> and recursed into via the interpreter. This takes precedence over <a href="#JuliaInterpreter.compiled_methods"><code>compiled_methods</code></a> and <a href="#JuliaInterpreter.compiled_modules"><code>compiled_modules</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/construct.jl#L23-L27">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.eval_code" href="#JuliaInterpreter.eval_code"><code>JuliaInterpreter.eval_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_code(frame::Frame, code::Union{String, Expr})</code></pre><p>Evaluate <code>code</code> in the context of <code>frame</code>, updating any local variables (including type parameters) that are reassigned in <code>code</code>, however, new local variables cannot be introduced.</p><pre><code class="language-julia-repl hljs">julia&gt; foo(x, y) = x + y;

julia&gt; frame = JuliaInterpreter.enter_call(foo, 1, 3);

julia&gt; JuliaInterpreter.eval_code(frame, &quot;x + y&quot;)
4

julia&gt; JuliaInterpreter.eval_code(frame, &quot;x = 5&quot;);

julia&gt; JuliaInterpreter.finish_and_return!(frame)
8</code></pre><p>When variables are captured in closures (and thus gets wrapped in a <code>Core.Box</code>) they will be automatically unwrapped and rewrapped upon evaluating them:</p><pre><code class="language-julia-repl hljs">julia&gt; function capture()
           x = 1
           f = ()-&gt;(x = 2) # x captured in closure and is thus a Core.Box
           f()
           x
       end;

julia&gt; frame = JuliaInterpreter.enter_call(capture);

julia&gt; JuliaInterpreter.step_expr!(frame);

julia&gt; JuliaInterpreter.step_expr!(frame);

julia&gt; JuliaInterpreter.locals(frame)
2-element Vector{JuliaInterpreter.Variable}:
 #self# = capture
 x = Core.Box(1)

julia&gt; JuliaInterpreter.eval_code(frame, &quot;x&quot;)
1

julia&gt; JuliaInterpreter.eval_code(frame, &quot;x = 2&quot;)
2

julia&gt; JuliaInterpreter.locals(frame)
2-element Vector{JuliaInterpreter.Variable}:
 #self# = capture
 x = Core.Box(2)</code></pre><p>&quot;Special&quot; values like SSA values and slots (shown in lowered code as e.g. <code>%3</code> and <code>@_4</code> respectively) can be evaluated using the syntax <code>var&quot;%3&quot;</code> and <code>var&quot;@_4&quot;</code> respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L593-L650">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.@lookup" href="#JuliaInterpreter.@lookup"><code>JuliaInterpreter.@lookup</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">rhs = @lookup(frame, node)
rhs = @lookup(mod, frame, node)</code></pre><p>This macro looks up previously-computed values referenced as SSAValues, SlotNumbers, GlobalRefs, QuoteNode, sparam or exception reference expression. It will also lookup symbols in <code>moduleof(frame)</code>; this can be supplied ahead-of-time via the 3-argument version. If none of the above apply, the value of <code>node</code> will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/interpret.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.is_wrapper_call" href="#JuliaInterpreter.is_wrapper_call"><code>JuliaInterpreter.is_wrapper_call</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Determine whether we are calling a function for which the current function is a wrapper (either because of optional arguments or because of keyword arguments).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L216-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.is_doc_expr" href="#JuliaInterpreter.is_doc_expr"><code>JuliaInterpreter.is_doc_expr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_doc_expr(ex)</code></pre><p>Test whether expression <code>ex</code> is a <code>@doc</code> expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L233-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.is_global_ref" href="#JuliaInterpreter.is_global_ref"><code>JuliaInterpreter.is_global_ref</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_global_ref(g, mod, name)</code></pre><p>Tests whether <code>g</code> is equal to <code>GlobalRef(mod, name)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodeTracking.whereis" href="#CodeTracking.whereis"><code>CodeTracking.whereis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">loc = whereis(frame, pc::Int=frame.pc; macro_caller=false)</code></pre><p>Return the file and line number for <code>frame</code> at <code>pc</code>.  If this cannot be determined, <code>loc == nothing</code>. Otherwise <code>loc == (filepath, line)</code>.</p><p>By default, any statements expanded from a macro are attributed to the macro definition, but with<code>macro_caller=true</code> you can obtain the location within the method that issued the macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L340-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.linenumber" href="#JuliaInterpreter.linenumber"><code>JuliaInterpreter.linenumber</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">line = linenumber(framecode, pc)</code></pre><p>Return the &quot;static&quot; line number at statement index <code>pc</code>. The static line number is the location at the time the method was most recently defined. See <a href="#CodeTracking.whereis"><code>CodeTracking.whereis</code></a> for dynamic line information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L359-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.Variable" href="#JuliaInterpreter.Variable"><code>JuliaInterpreter.Variable</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>Variable</code> is a struct representing a variable with an asigned value. By calling the function <a href="#JuliaInterpreter.locals"><code>locals</code></a> on a <a href="#JuliaInterpreter.Frame"><code>Frame</code></a> a <code>Vector</code> of <code>Variable</code>&#39;s is returned.</p><p>Important fields:</p><ul><li><code>value::Any</code>: the value of the local variable.</li><li><code>name::Symbol</code>: the name of the variable as given in the source code.</li><li><code>isparam::Bool</code>: if the variable is a type parameter, for example <code>T</code> in <code>f(x::T) where {T} = x</code>.</li><li><code>is_captured_closure::Bool</code>: if the variable has been captured by a closure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/types.jl#L328-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.locals" href="#JuliaInterpreter.locals"><code>JuliaInterpreter.locals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_variables = locals(frame::Frame)::Vector{Variable}</code></pre><p>Return the local variables as a vector of <a href="#JuliaInterpreter.Variable"><code>Variable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L535-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.whichtt" href="#JuliaInterpreter.whichtt"><code>JuliaInterpreter.whichtt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">method = whichtt(tt)</code></pre><p>Like <code>which</code> except it operates on the complete tuple-type <code>tt</code>, and doesn&#39;t throw when there is no matching method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/utils.jl#L28-L33">source</a></section></article><h2 id="Hooks"><a class="docs-heading-anchor" href="#Hooks">Hooks</a><a id="Hooks-1"></a><a class="docs-heading-anchor-permalink" href="#Hooks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.on_breakpoints_updated" href="#JuliaInterpreter.on_breakpoints_updated"><code>JuliaInterpreter.on_breakpoints_updated</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">on_breakpoints_updated(f)</code></pre><p>Register a one-argument function to be called after any update to the set of all breakpoints. This includes their creation, deletion, enabling and disabling.</p><p>The function <code>f</code> should take two inputs:</p><ul><li>First argument is the function doing to update, this is provided to allow to dispatch on its type. It will be one:<ul><li><code>::typeof(breakpoint)</code> for the creation,</li><li><code>::typeof(remove)</code> for the deletion.</li><li><code>::typeof(update_states)</code> for disable/enable/toggleing</li></ul></li><li>Second argument is the breakpoint object that was changed.</li></ul><p>If only desiring to handle some kinds of update, <code>f</code> should have fallback methods to do nothing in the general case.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This feature is experimental, and may be modified or removed in a minor release.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L14-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuliaInterpreter.firehooks" href="#JuliaInterpreter.firehooks"><code>JuliaInterpreter.firehooks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">firehooks(hooked_fun, bp::AbstractBreakpoint)</code></pre><p>Trigger all hooks that were registered with <a href="#JuliaInterpreter.on_breakpoints_updated"><code>on_breakpoints_updated</code></a>, passing them the <code>hooked_fun</code> and the <code>bp</code>. This should be called whenever the set of breakpoints is updated. <code>hooked_fun</code> is the function doing the update, and <code>bp</code> is the relevent breakpoint being updated <em>after</em> the update is applied.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This feature is experimental, and may be modified or removed in a minor release.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/0169df21452c65cd49904a75f7208724db625ea5/src/breakpoints.jl#L37-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« Internals</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 11 August 2023 13:16">Friday 11 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
