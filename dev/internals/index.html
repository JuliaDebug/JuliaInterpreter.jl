<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · JuliaInterpreter.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaInterpreter.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../ast/">Lowered representation</a></li><li class="current"><a class="toctext" href>Internals</a><ul class="internal"><li><a class="toctext" href="#Basic-usage-1">Basic usage</a></li><li><a class="toctext" href="#More-complex-expressions-1">More complex expressions</a></li><li><a class="toctext" href="#Toplevel-code-and-world-age-1">Toplevel code and world age</a></li></ul></li><li><a class="toctext" href="../dev_reference/">Function reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Internals</a></li></ul><a class="edit-page" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h1><h2><a class="nav-anchor" id="Basic-usage-1" href="#Basic-usage-1">Basic usage</a></h2><p>The process of executing code in the interpreter is to prepare a <code>frame</code> and then evaluate these statements one-by-one, branching via the <code>goto</code> statements as appropriate. Using the <code>summer</code> example described in <a href="../ast/#Lowered-representation-1">Lowered representation</a>, let&#39;s build a frame:</p><pre><code class="language-julia">julia&gt; frame = JuliaInterpreter.enter_call(summer, A)
JuliaStackFrame(JuliaInterpreter.JuliaFrameCode(summer(A::AbstractArray{T,N} where N) where T in Main at REPL[1]:2, CodeInfo(
1 ─       s = ($(QuoteNode(zero)))($(Expr(:static_parameter, 1)))
│   %2  = A
│         #temp# = ($(QuoteNode(iterate)))(%2)
│   %4  = ($(QuoteNode(===)))(#temp#, nothing)
│   %5  = ($(QuoteNode(not_int)))(%4)
└──       goto #4 if not %5
2 ┄ %7  = #temp#
│         a = ($(QuoteNode(getfield)))(%7, 1)
│   %9  = ($(QuoteNode(getfield)))(%7, 2)
│         s = ($(QuoteNode(+)))(s, a)
│         #temp# = ($(QuoteNode(iterate)))(%2, %9)
│   %12 = ($(QuoteNode(===)))(#temp#, nothing)
│   %13 = ($(QuoteNode(not_int)))(%12)
└──       goto #4 if not %13
3 ─       goto #2
4 ┄       return s
), Core.TypeMapEntry[#undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef], BitSet([2, 4, 5, 7, 9, 12, 13]), false, false, true), Union{Nothing, Some{Any}}[Some(summer), Some([1, 2, 5]), nothing, nothing, nothing], Any[#undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef, #undef], Any[Int64], Int64[], Base.RefValue{Any}(nothing), Base.RefValue{JuliaInterpreter.JuliaProgramCounter}(JuliaProgramCounter(1)), Dict{Symbol,Int64}(), Any[])</code></pre><p>This is a <a href="../dev_reference/#JuliaInterpreter.JuliaStackFrame"><code>JuliaInterpreter.JuliaStackFrame</code></a>. The <code>CodeInfo</code> is the most prominent part of this display, and extractable as <code>code = frame.code.code</code>. (It&#39;s a slightly modified form of one returned by <code>@code_lowered</code>, in that it has been processed by <a href="../dev_reference/#JuliaInterpreter.optimize!"><code>JuliaInterpreter.optimize!</code></a> to speed up run-time execution.)</p><p>Much of the rest of the <code>frame</code> holds values needed for or generated by execution. The input arguments are in <code>locals</code>:</p><pre><code class="language-julia">julia&gt; frame.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 nothing
 nothing
 nothing</code></pre><p>These correspond to the <code>code.slotnames</code>; the first is the <code>#self#</code> argument and the second is the input array. The remaining local variables (e.g., <code>s</code> and <code>a</code>), have not yet been assigned–-we&#39;ve only built the frame, but we haven&#39;t yet begun to execute it. The static parameter, <code>T</code>, is stored in <code>frame.sparams</code>:</p><pre><code class="language-julia">julia&gt; frame.sparams
1-element Array{Any,1}:
 Int64</code></pre><p>The <code>Expr(:static_parameter, 1)</code> statement refers to this value.</p><p>The other main storage is for the generated SSA values:</p><pre><code class="language-julia">julia&gt; frame.ssavalues
16-element Array{Any,1}:
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef</code></pre><p>Since we haven&#39;t executed any statements yet, these are all undefined.</p><p>The other main entity is the so-called <a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>, which just indicates the next statement to be executed:</p><pre><code class="language-julia">julia&gt; frame.pc[]
JuliaProgramCounter(1)</code></pre><p>This is stored as a <code>Ref</code> so that it can be updated as execution progresses.</p><p>Let&#39;s try executing the first statement. So that we can recurse into calls (e.g., <code>iterate</code>, <code>+</code>, etc.,), we&#39;ll create a <a href="https://en.wikipedia.org/wiki/Call_stack">stack</a> of frames and then run the first statement:</p><pre><code class="language-julia">julia&gt; stack = JuliaInterpreter.JuliaStackFrame[]
0-element Array{JuliaStackFrame,1}

julia&gt; JuliaInterpreter.step_expr!(stack, frame)
JuliaProgramCounter(2)</code></pre><p>This indicates that it ran statement 1 and is prepared to run statement 2. (It&#39;s worth noting that the first line included a <code>call</code> to <code>zero</code>, so behind the scenes JuliaInterpreter pushed this frame onto <code>stack</code>, created a new frame for <code>zero</code>, executed all the statements, and then popped the stack.) Since the first statement is an assignment of a local variable, let&#39;s check the locals again:</p><pre><code class="language-julia">julia&gt; frame.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 Some(0)
 nothing
 nothing</code></pre><p>You can see that the entry corresponding to <code>s</code> has been initialized.</p><p>The next statement just retrieves one of the slots (the input argument <code>A</code>) and stores it in an SSA value:</p><pre><code class="language-julia">julia&gt; JuliaInterpreter.step_expr!(stack, frame)
JuliaProgramCounter(3)

julia&gt; frame.ssavalues
16-element Array{Any,1}:
 #undef
    [1, 2, 5]
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef</code></pre><p>One can easily continue this until execution completes, which is indicated when <code>step_expr!</code> returns <code>nothing</code>. Alternatively, use the higher-level <code>JuliaInterpreter.finish!(stack, frame)</code> to step through the entire frame, or <code>JuliaInterpreter.finish_and_return!(stack, frame)</code> to also obtain the return value.</p><h2><a class="nav-anchor" id="More-complex-expressions-1" href="#More-complex-expressions-1">More complex expressions</a></h2><p>Sometimes you might have a whole sequence of expressions you want to run. In such cases, your first thought should be <code>prepare_thunk</code>. Here&#39;s a demonstration:</p><pre><code class="language-julia">using Test

ex = quote
    x, y = 1, 2
    @test x + y == 3
end

frame = JuliaInterpreter.prepare_thunk(Main, ex)
JuliaInterpreter.finish_and_return!(JuliaStackFrame[], frame)

# output

Test Passed</code></pre><h2><a class="nav-anchor" id="Toplevel-code-and-world-age-1" href="#Toplevel-code-and-world-age-1">Toplevel code and world age</a></h2><p>Code that defines new <code>struct</code>s, new methods, or new modules is a bit more complicated and requires special handling. In such cases, calling <code>finish_and_return!</code> on a frame that defines these new objects and then calls them can trigger a <a href="https://docs.julialang.org/en/latest/manual/methods/#Redefining-Methods-1">world age error</a>, in which the method is considered to be too new to be run by the currently compiled code. While one can resolve this by using <code>Base.invokelatest</code>, we&#39;d have to use that strategy throughout the entire package.  This would cause a major reduction in performance. To resolve this issue without leading to performance problems, care is required to return to &quot;top level&quot; after defining such objects. This leads to altered syntax for executing such expressions.</p><p>Here&#39;s a demonstration of the problem:</p><pre><code class="language-julia">ex = :(map(x-&gt;x^2, [1, 2, 3]))
frame = JuliaInterpreter.prepare_thunk(Main, ex)
julia&gt; JuliaInterpreter.finish_and_return!(JuliaStackFrame[], frame)
ERROR: this frame needs to be run a top level</code></pre><p>The reason for this error becomes clearer if we examine <code>frame</code> or look directly at the lowered code:</p><pre><code class="language-julia">julia&gt; Meta.lower(Main, ex)
:($(Expr(:thunk, CodeInfo(
1 ─      $(Expr(:thunk, CodeInfo(
1 ─     global ##17#18
│       const ##17#18
│       $(Expr(:struct_type, Symbol(&quot;##17#18&quot;), :((Core.svec)()), :((Core.svec)()), :(Core.Function), :((Core.svec)()), false, 0))
└──     return
)))
│   %2 = (Core.svec)(##17#18, Core.Any)
│   %3 = (Core.svec)()
│   %4 = (Core.svec)(%2, %3)
│        $(Expr(:method, false, :(%4), CodeInfo(quote
    (Core.apply_type)(Base.Val, 2)
    (%1)()
    (Base.literal_pow)(^, x, %2)
    return %3
end)))
│        #17 = %new(##17#18)
│   %7 = #17
│   %8 = (Base.vect)(1, 2, 3)
│   %9 = map(%7, %8)
└──      return %9
))))</code></pre><p>All of the code before the <code>%7</code> line is devoted to defining the anonymous function <code>x-&gt;x^2</code>: it creates a new &quot;anonymous type&quot; (here written as <code>##17#18</code>), and then defines a &quot;call function&quot; for this type, equivalent to <code>(##17#18)(x) = x^2</code>.</p><p>In some cases one can fix this simply by indicating that we want to run this frame at top level:</p><pre><code class="language-julia">julia&gt; JuliaInterpreter.finish_and_return!(JuliaStackFrame[], frame, true)
3-element Array{Int64,1}:
 1
 4
 9</code></pre><p>Here&#39;s a more fine-grained look at what&#39;s happening under the hood (and a robust strategy for more complex situations where there may be nested calls of new methods):</p><pre><code class="language-julia">modexs, _ = JuliaInterpreter.split_expressions(Main, ex)
stack = JuliaStackFrame[]
for (mod, e) in modexs
    frame = JuliaInterpreter.prepare_thunk(mod, e)
    while true
        JuliaInterpreter.through_methoddef_or_done!(stack, frame) === nothing &amp;&amp; break
    end
    JuliaInterpreter.get_return(frame)
end</code></pre><p>This splits the expression into a sequence of frames (here just one, but more complex blocks may be split up into many). Then, each frame is executed until it finishes defining a new method, then returns to top level. The return to top level causes an update in the world age. If the frame hasn&#39;t been finished yet (if the return value wasn&#39;t <code>nothing</code>), this continues executing where it left off.</p><p>(Incidentally, <code>JuliaInterpreter.enter_call(map, x-&gt;x^2, [1, 2, 3])</code> works fine on its own, because the anonymous function is defined by the caller–-you&#39;ll see that the created frame is very simple.)</p><footer><hr/><a class="previous" href="../ast/"><span class="direction">Previous</span><span class="title">Lowered representation</span></a><a class="next" href="../dev_reference/"><span class="direction">Next</span><span class="title">Function reference</span></a></footer></article></body></html>
