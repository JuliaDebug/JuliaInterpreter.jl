<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · JuliaInterpreter.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaInterpreter.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../ast/">Lowered representation</a></li><li><a class="toctext" href="../internals/">Internals</a></li><li class="current"><a class="toctext" href>Function reference</a><ul class="internal"><li><a class="toctext" href="#Running-the-interpreter-1">Running the interpreter</a></li><li><a class="toctext" href="#Frame-creation-1">Frame creation</a></li><li><a class="toctext" href="#Frame-traversal-1">Frame traversal</a></li><li><a class="toctext" href="#Frame-execution-1">Frame execution</a></li><li><a class="toctext" href="#Breakpoints-1">Breakpoints</a></li><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Internal-storage-1">Internal storage</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/master/docs/src/dev_reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Function-reference-1" href="#Function-reference-1">Function reference</a></h1><h2><a class="nav-anchor" id="Running-the-interpreter-1" href="#Running-the-interpreter-1">Running the interpreter</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.@interpret" href="#JuliaInterpreter.@interpret"><code>JuliaInterpreter.@interpret</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@interpret f(args; kwargs...)</code></pre><p>Evaluate <code>f</code> on the specified arguments using the interpreter.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1, 7]
2-element Array{Int64,1}:
 1
 7

julia&gt; sum(a)
8

julia&gt; @interpret sum(a)
8</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L611-L630">source</a></section><h2><a class="nav-anchor" id="Frame-creation-1" href="#Frame-creation-1">Frame creation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.enter_call" href="#JuliaInterpreter.enter_call"><code>JuliaInterpreter.enter_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = enter_call(f, args...; kwargs...)</code></pre><p>Build a <code>Frame</code> ready to execute <code>f</code> with the specified positional and keyword arguments.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call(mymethod, 1)
Frame for mymethod(x) in Main at none:1
  1* 1  1 ─ %1 = (+)(x, 1)
  2  1  └──      return %1
x = 1

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.enter_call(mymethod, [1.0, 2.0])
Frame for mymethod(x::Array{T,1}) where T in Main at none:1
  1* 1  1 ─     return 1
x = [1.0, 2.0]
T = Float64</code></pre><p>For a <code>@generated</code> function you can use <code>enter_call((f, true), args...; kwargs...)</code> to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p>See <a href="#JuliaInterpreter.enter_call_expr"><code>enter_call_expr</code></a> for a similar approach based on expressions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L514-L546">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.enter_call_expr" href="#JuliaInterpreter.enter_call_expr"><code>JuliaInterpreter.enter_call_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = enter_call_expr(expr; enter_generated=false)</code></pre><p>Build a <code>Frame</code> ready to execute the expression <code>expr</code>. Set <code>enter_generated=true</code> if you want to execute the generator of a <code>@generated</code> function, rather than the code that would be created by the generator.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = x+1
mymethod (generic function with 1 method)

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod(1)))
Frame for mymethod(x) in Main at none:1
  1* 1  1 ─ %1 = (+)(x, 1)
  2  1  └──      return %1
x = 1

julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 2 methods)

julia&gt; a = [1.0, 2.0]
2-element Array{Float64,1}:
 1.0
 2.0

julia&gt; JuliaInterpreter.enter_call_expr(:($mymethod($a)))
Frame for mymethod(x::Array{T,1}) where T in Main at none:1
  1* 1  1 ─     return 1
x = [1.0, 2.0]
T = Float64</code></pre><p>See <a href="#JuliaInterpreter.enter_call"><code>enter_call</code></a> for a similar approach not based on expressions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L470-L505">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_frame" href="#JuliaInterpreter.prepare_frame"><code>JuliaInterpreter.prepare_frame</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = prepare_frame(framecode::FrameCode, frameargs, lenv)</code></pre><p>Construct a new <code>Frame</code> for <code>framecode</code>, given lowered-code arguments <code>frameargs</code> and static parameters <code>lenv</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about how to prepare the inputs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L289-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.determine_method_for_expr" href="#JuliaInterpreter.determine_method_for_expr"><code>JuliaInterpreter.determine_method_for_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, frameargs, lenv, argtypes = determine_method_for_expr(expr; enter_generated = false)</code></pre><p>Prepare all the information needed to execute a particular <code>:call</code> expression <code>expr</code>. For example, try <code>JuliaInterpreter.determine_method_for_expr(:(sum([1,2])))</code>. See <a href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> for information about the outputs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L451-L457">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_args" href="#JuliaInterpreter.prepare_args"><code>JuliaInterpreter.prepare_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frun, allargs = prepare_args(fcall, fargs, kwargs)</code></pre><p>Prepare the complete argument sequence for a call to <code>fcall</code>. <code>fargs = [fcall, args...]</code> is a list containing both <code>fcall</code> (the <code>#self#</code> slot in lowered code) and the positional arguments supplied to <code>fcall</code>. <code>kwargs</code> is a list of keyword arguments, supplied either as list of expressions <code>:(kwname=kwval)</code> or pairs <code>:kwname=&gt;kwval</code>.</p><p>For non-keyword methods, <code>frun === fcall</code>, but for methods with keywords <code>frun</code> will be the keyword-sorter function for <code>fcall</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x) = 1
mymethod (generic function with 1 method)

julia&gt; mymethod(x, y; verbose=false) = nothing
mymethod (generic function with 2 methods)

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 15], ())
(mymethod, Any[mymethod, 15])

julia&gt; JuliaInterpreter.prepare_args(mymethod, [mymethod, 1, 2], [:verbose=&gt;true])
(getfield( Symbol(&quot;#kw##mymethod&quot;))(), Any[#kw##mymethod(), (verbose = true,), mymethod, 1, 2])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L72-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_call" href="#JuliaInterpreter.prepare_call"><code>JuliaInterpreter.prepare_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, frameargs, lenv, argtypes = prepare_call(f, allargs; enter_generated=false)</code></pre><p>Prepare all the information needed to execute lowered code for <code>f</code> given arguments <code>allargs</code>. <code>f</code> and <code>allargs</code> are the outputs of <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>. For <code>@generated</code> methods, set <code>enter_generated=true</code> if you want to extract the lowered code of the generator itself.</p><p>On return <code>framecode</code> is the <a href="#JuliaInterpreter.FrameCode"><code>FrameCode</code></a> of the method. <code>frameargs</code> contains the actual arguments needed for executing this frame (for generators, this will be the types of <code>allargs</code>); <code>lenv</code> is the &quot;environment&quot;, i.e., the static parameters for <code>f</code> given <code>allargs</code>. <code>argtypes</code> is the <code>Tuple</code>-type for this specific call (equivalent to the signature of the <code>MethodInstance</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; mymethod(x::Vector{T}) where T = 1
mymethod (generic function with 1 method)

julia&gt; framecode, frameargs, lenv, argtypes = JuliaInterpreter.prepare_call(mymethod, [mymethod, [1.0,2.0]]);

julia&gt; framecode
  1  1  1 ─     return 1

julia&gt; frameargs
2-element Array{Any,1}:
 mymethod
 [1.0, 2.0]

julia&gt; lenv
svec(Float64)

julia&gt; argtypes
Tuple{typeof(mymethod),Array{Float64,1}}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L168-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.prepare_thunk" href="#JuliaInterpreter.prepare_thunk"><code>JuliaInterpreter.prepare_thunk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = prepare_thunk(mod::Module, expr::Expr)</code></pre><p>Prepare <code>expr</code> for evaluation in <code>mod</code>. <code>expr</code> should be a &quot;straightforward&quot; expression, one that does not require special top-level handling (see <a href="#JuliaInterpreter.split_expressions"><code>JuliaInterpreter.split_expressions</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L313-L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.split_expressions" href="#JuliaInterpreter.split_expressions"><code>JuliaInterpreter.split_expressions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modexs, docexprs = split_expressions(mod::Module, expr::Expr; extract_docexprs=false)</code></pre><p>Break <code>expr</code> into a list <code>modexs</code> of sequential blocks. This is often needed when <code>expr</code> needs to be evaluated at top level.</p><p><code>modexs[i]</code> is a <code>(mod::Module, ex::Expr)</code> tuple, where <code>ex</code> is to be evaluated in <code>mod</code>.</p><p><strong>Toplevel evaluation</strong></p><p>For code that defines new structs, new methods, or new macros, it can be important to evaluate these expressions carefully:</p><pre><code class="language-none">stack = Frame[]
for modex in modexs    # or use `for (mod, ex) in modexs` to split the tuple
    frame = JuliaInterpreter.prepare_thunk(modex)
    while true
        JuliaInterpreter.through_methoddef_or_done!(stack, frame) === nothing &amp;&amp; break
    end
end</code></pre><p>The <code>while</code> loop here deserves some explanation. Occasionally, a frame may define new methods (e.g., anonymous or local functions) and then call those methods. In such cases, running the entire frame as a single block (e.g., with <a href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a> can trigger &quot;method is too new...&quot; errors. Instead, the approach above runs each frame, but returns to the caller after any new method is defined. When this loop is running at top level (e.g., in the REPL), this allows the world age to update and thus avoid &quot;method is too new...&quot; errors.</p><p>Putting the above nested loop inside a function defeats its purpose, because inside a compiled function the world age will not update. If necessary, use the following strategy:</p><pre><code class="language-none">Core.eval(somemodule, Expr(:toplevel, quote
    body
))</code></pre><p>where <code>body</code> contains the nested loop, plus any preparatory statements required to make the necessary variables available at top level in <code>somemodule</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L341-L379">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.get_call_framecode" href="#JuliaInterpreter.get_call_framecode"><code>JuliaInterpreter.get_call_framecode</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">framecode, lenv = get_call_framecode(fargs, parentframe::FrameCode, idx::Int)</code></pre><p>Return the framecode and environment for a call specified by <code>fargs = [f, args...]</code> (see <a href="#JuliaInterpreter.prepare_args"><code>prepare_args</code></a>). <code>parentframecode</code> is the caller, and <code>idx</code> is the program-counter index. If possible, <code>framecode</code> will be looked up from the local method tables of <code>parentframe</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/localmethtable.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.optimize!" href="#JuliaInterpreter.optimize!"><code>JuliaInterpreter.optimize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">optimize!(code::CodeInfo, mod::Module)</code></pre><p>Perform minor optimizations on the lowered AST in <code>code</code> to reduce execution time of the interpreter. Currently it looks up <code>GlobalRef</code>s (for which it needs <code>mod</code> to know the scope in which this will run) and ensures that no statement includes nested <code>:call</code> expressions (splitting them out into multiple SSA-form statements if needed).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/optimize.jl#L98-L106">source</a></section><h2><a class="nav-anchor" id="Frame-traversal-1" href="#Frame-traversal-1">Frame traversal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.root" href="#JuliaInterpreter.root"><code>JuliaInterpreter.root</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">rframe = root(frame)</code></pre><p>Return the initial frame in the call stack.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L164-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.leaf" href="#JuliaInterpreter.leaf"><code>JuliaInterpreter.leaf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">lframe = leaf(frame)</code></pre><p>Return the deepest callee in the call stack.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L171-L175">source</a></section><h2><a class="nav-anchor" id="Frame-execution-1" href="#Frame-execution-1">Frame execution</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Compiled" href="#JuliaInterpreter.Compiled"><code>JuliaInterpreter.Compiled</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Compiled</code> is a trait indicating that any <code>:call</code> expressions should be evaluated using Julia&#39;s normal compiled-code evaluation. The alternative is to pass <code>stack=Frame[]</code>, which will cause all calls to be evaluated via the interpreter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.step_expr!" href="#JuliaInterpreter.step_expr!"><code>JuliaInterpreter.step_expr!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = step_expr!(recurse, frame, istoplevel=false)
pc = step_expr!(frame, istoplevel=false)</code></pre><p>Execute the next statement in <code>frame</code>. <code>pc</code> is the new program counter, or <code>nothing</code> if execution terminates, or a <a href="#JuliaInterpreter.BreakpointRef"><code>BreakpointRef</code></a> if execution hits a breakpoint.</p><p><code>recurse</code> controls call evaluation; <code>recurse = Compiled()</code> evaluates :call expressions by normal dispatch. The default value <code>recurse = finish_and_return!</code> will use recursive interpretation.</p><p>If you are evaluating <code>frame</code> at module scope you should pass <code>istoplevel=true</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/interpret.jl#L523-L535">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish!" href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = finish!(recurse, frame, istoplevel=false)
pc = finish!(frame, istoplevel=false)</code></pre><p>Run <code>frame</code> until execution terminates. <code>pc</code> is either <code>nothing</code> (if execution terminates when it hits a <code>return</code> statement) or a reference to a breakpoint. In the latter case, <code>leaf(frame)</code> returns the frame in which it hit the breakpoint.</p><p><code>recurse</code> controls call evaluation; <code>recurse = Compiled()</code> evaluates :call expressions by normal dispatch, whereas the default <code>recurse = finish_and_return!</code> uses recursive interpretation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish_and_return!" href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = finish_and_return!(recurse, frame, istoplevel::Bool=false)
ret = finish_and_return!(frame, istoplevel::Bool=false)</code></pre><p>Call <a href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a> and pass back the return value <code>ret</code>. If execution pauses at a breakpoint, <code>ret</code> is the reference to the breakpoint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L21-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.finish_stack!" href="#JuliaInterpreter.finish_stack!"><code>JuliaInterpreter.finish_stack!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = finish_stack!(recurse, frame, rootistoplevel=false)
ret = finish_stack!(frame, rootistoplevel=false)</code></pre><p>Unwind the callees of <code>frame</code>, finishing each before returning to the caller. <code>frame</code> itself is also finished. <code>rootistoplevel</code> should be true if the root frame is top-level.</p><p><code>ret</code> is typically the returned value. If execution hits a breakpoint, <code>ret</code> will be a reference to the breakpoint.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L44-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.get_return" href="#JuliaInterpreter.get_return"><code>JuliaInterpreter.get_return</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = get_return(frame)</code></pre><p>Get the return value of <code>frame</code>. Throws an error if <code>frame.pc</code> does not point to a <code>return</code> expression. <code>frame</code> must have already been executed so that the return value has been computed (see, e.g., <a href="#JuliaInterpreter.finish!"><code>JuliaInterpreter.finish!</code></a>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/interpret.jl#L595-L601">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.next_until!" href="#JuliaInterpreter.next_until!"><code>JuliaInterpreter.next_until!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = next_until!(predicate, recurse, frame, istoplevel=false)
pc = next_until!(predicate, frame, istoplevel=false)</code></pre><p>Execute the current statement. Then step through statements of <code>frame</code> until the next statement satifies <code>predicate(stmt)</code>. <code>pc</code> will be the index of the statement at which evaluation terminates, <code>nothing</code> (if the frame reached a <code>return</code>), or a <code>BreakpointRef</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L84-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.through_methoddef_or_done!" href="#JuliaInterpreter.through_methoddef_or_done!"><code>JuliaInterpreter.through_methoddef_or_done!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = through_methoddef_or_done!(recurse, frame)
pc = through_methoddef_or_done!(frame)</code></pre><p>Runs <code>frame</code> at top level until it either finishes (e.g., hits a <code>return</code> statement) or defines a new method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L131-L137">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.evaluate_call!" href="#JuliaInterpreter.evaluate_call!"><code>JuliaInterpreter.evaluate_call!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = evaluate_call!(Compiled(), frame::Frame, call_expr)
ret = evaluate_call!(recurse,    frame::Frame, call_expr)</code></pre><p>Evaluate a <code>:call</code> expression <code>call_expr</code> in the context of <code>frame</code>. The first causes it to be executed using Julia&#39;s normal dispatch (compiled code), whereas the second recurses in via the interpreter. <code>recurse</code> has a default value of <a href="#JuliaInterpreter.finish_and_return!"><code>JuliaInterpreter.finish_and_return!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/interpret.jl#L245-L253">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.evaluate_foreigncall" href="#JuliaInterpreter.evaluate_foreigncall"><code>JuliaInterpreter.evaluate_foreigncall</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = evaluate_foreigncall(frame::Frame, call_expr)</code></pre><p>Evaluate a <code>:foreigncall</code> (from a <code>ccall</code>) statement <code>callexpr</code> in the context of <code>frame</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/interpret.jl#L146-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.maybe_evaluate_builtin" href="#JuliaInterpreter.maybe_evaluate_builtin"><code>JuliaInterpreter.maybe_evaluate_builtin</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = maybe_evaluate_builtin(frame, call_expr, expand::Bool)</code></pre><p>If <code>call_expr</code> is to a builtin function, evaluate it, returning the result inside a <code>Some</code> wrapper. Otherwise, return <code>call_expr</code>.</p><p>If <code>expand</code> is true, <code>Core._apply</code> calls will be resolved as a call to the applied function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/builtins-julia1.1.jl#L12-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.maybe_next_call!" href="#JuliaInterpreter.maybe_next_call!"><code>JuliaInterpreter.maybe_next_call!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = maybe_next_call!(recurse, frame, istoplevel=false)
pc = maybe_next_call!(frame, istoplevel=false)</code></pre><p>Return the current program counter of <code>frame</code> if it is a <code>:return</code> or <code>:call</code> expression. Otherwise, step through the statements of <code>frame</code> until the next <code>:return</code> or <code>:call</code> expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L116-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.next_line!" href="#JuliaInterpreter.next_line!"><code>JuliaInterpreter.next_line!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = next_line!(recurse, frame, istoplevel=false)
pc = next_line!(frame, istoplevel=false)</code></pre><p>Execute until reaching the first call of the next line of the source code. Upon return, <code>pc</code> is either the new program counter, <code>nothing</code> if a <code>return</code> is reached, or a <code>BreakpointRef</code> if it encountered a wrapper call. In the latter case, call <code>leaf(frame)</code> to obtain the new execution frame.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L168-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.next_call!" href="#JuliaInterpreter.next_call!"><code>JuliaInterpreter.next_call!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">pc = next_call!(recurse, frame, istoplevel=false)
pc = next_call!(frame, istoplevel=false)</code></pre><p>Execute the current statement. Continue stepping through <code>frame</code> until the next <code>:return</code> or <code>:call</code> expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L105-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.maybe_reset_frame!" href="#JuliaInterpreter.maybe_reset_frame!"><code>JuliaInterpreter.maybe_reset_frame!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = maybe_reset_frame!(recurse, frame, pc, rootistoplevel)</code></pre><p>Perform a return to the caller, or descend to the level of a breakpoint. <code>pc</code> is the return state from the previous command (e.g., <code>next_call!</code> or similar). <code>rootistoplevel</code> should be true if the root frame is top-level.</p><p><code>ret</code> will be <code>nothing</code> if we have just completed a top-level frame. Otherwise,</p><pre><code class="language-none">cframe, cpc = ret</code></pre><p>where <code>cframe</code> is the frame from which execution should continue and <code>cpc</code> is the state of <code>cframe</code> (the program counter, a <code>BreakpointRef</code>, or <code>nothing</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L332-L345">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.maybe_step_through_wrapper!" href="#JuliaInterpreter.maybe_step_through_wrapper!"><code>JuliaInterpreter.maybe_step_through_wrapper!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">cframe = maybe_step_through_wrapper!(recurse, frame)
cframe = maybe_step_through_wrapper!(frame)</code></pre><p>Return the new frame of execution, potentially stepping through &quot;wrapper&quot; methods like those that supply default positional arguments or handle keywords. <code>cframe</code> is the leaf frame from which execution should start.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L227-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.maybe_step_through_kwprep!" href="#JuliaInterpreter.maybe_step_through_kwprep!"><code>JuliaInterpreter.maybe_step_through_kwprep!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">frame = maybe_step_through_kwprep!(recurse, frame)
frame = maybe_step_through_kwprep!(frame)</code></pre><p>If <code>frame.pc</code> points to the beginning of preparatory work for calling a keyword-argument function, advance forward until the actual call.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L259-L265">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.handle_err" href="#JuliaInterpreter.handle_err"><code>JuliaInterpreter.handle_err</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">loc = handle_err(recurse, frame, err)</code></pre><p>Deal with an error <code>err</code> that arose while evaluating <code>frame</code>. There are one of three behaviors:</p><ul><li>if <code>frame</code> catches the error, <code>loc</code> is the program counter at which to resume evaluation of <code>frame</code>;</li><li>if <code>frame</code> doesn&#39;t catch the error, but <code>break_on_error[]</code> is <code>true</code>, <code>loc</code> is a <code>BreakpointRef</code>;</li><li>otherwise, <code>err</code> gets rethrown.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/interpret.jl#L541-L552">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.debug_command" href="#JuliaInterpreter.debug_command"><code>JuliaInterpreter.debug_command</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ret = debug_command(recurse, frame, cmd, rootistoplevel=false)
ret = debug_command(frame, cmd, rootistoplevel=false)</code></pre><p>Perform one &quot;debugger&quot; command. <code>cmd</code> should be one of:</p><ul><li><code>:n</code>: advance to the next line</li><li><code>:s</code>: step into the next call</li><li><code>:c</code>: continue execution until termination or reaching a breakpoint</li><li><code>:finish</code>: finish the current frame and return to the parent</li></ul><p>or one of the &#39;advanced&#39; commands</p><ul><li><code>:nc</code>: step forward to the next call</li><li><code>:se</code>: execute a single statement</li><li><code>:si</code>: execute a single statement, stepping in if it&#39;s a call</li><li><code>:sg</code>: step into the generator of a generated function</li></ul><p><code>rootistoplevel</code> and <code>ret</code> are as described for <a href="#JuliaInterpreter.maybe_reset_frame!"><code>JuliaInterpreter.maybe_reset_frame!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L385-L404">source</a></section><h2><a class="nav-anchor" id="Breakpoints-1" href="#Breakpoints-1">Breakpoints</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.@breakpoint" href="#JuliaInterpreter.@breakpoint"><code>JuliaInterpreter.@breakpoint</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@breakpoint f(args...) condition=nothing
@breakpoint f(args...) line condition=nothing</code></pre><p>Break upon entry, or at the specified line number, in the method called by <code>f(args...)</code>. Optionally supply a condition expressed in terms of the arguments and internal variables of the method. If <code>line</code> is supplied, it must be a literal integer.</p><p><strong>Example</strong></p><p>Suppose a method <code>mysum</code> is defined as follows, where the numbers to the left are the line number in the file:</p><pre><code class="language-none">12 function mysum(A)
13     s = zero(eltype(A))
14     for a in A
15         s += a
16     end
17     return s
18 end</code></pre><p>Then</p><pre><code class="language-none">@breakpoint mysum(A) 15 s&gt;10</code></pre><p>would cause execution of the loop to break whenever <code>s&gt;10</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L267-L298">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.@bp" href="#JuliaInterpreter.@bp"><code>JuliaInterpreter.@bp</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@bp</code></pre><p>Insert a breakpoint at a location in the source code.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L327-L331">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.breakpoint" href="#JuliaInterpreter.breakpoint"><code>JuliaInterpreter.breakpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">breakpoint(f, sig)
breakpoint(f, sig, line)
breakpoint(f, sig, condition)
breakpoint(f, sig, line, condition)
breakpoint(...; enter_generated=false)</code></pre><p>Add a breakpoint to <code>f</code> with the specified argument types <code>sig</code>. Optionally specify an absolute line number <code>line</code> in the source file; the default is to break upon entry at the first line of the body. Without <code>condition</code>, the breakpoint will be triggered every time it is encountered; the second only if <code>condition</code> evaluates to <code>true</code>. <code>condition</code> should be written in terms of the arguments and local variables of <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">function radius2(x, y)
    return x^2 + y^2
end

breakpoint(radius2, Tuple{Int,Int}, :(y &gt; x))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L166-L188">source</a><div><div><pre><code class="language-none">breakpoint(method::Method)
breakpoint(method::Method, line)
breakpoint(method::Method, condition::Expr)
breakpoint(method::Method, line, condition::Expr)</code></pre><p>Add a breakpoint to <code>method</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L203-L210">source</a><div><div><pre><code class="language-none">breakpoint(f)
breakpoint(f, condition)</code></pre><p>Break-on-entry to all methods of <code>f</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L220-L225">source</a><div><div><pre><code class="language-none">breakpoint(filename, line)
breakpoint(filename, line, condition)</code></pre><p>Set a breakpoint at the specified file and line number.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L234-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.enable" href="#JuliaInterpreter.enable"><code>JuliaInterpreter.enable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enable(bp::BreakpointRef)</code></pre><p>Enable breakpoint <code>bp</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L79-L83">source</a><div><div><pre><code class="language-none">enable()</code></pre><p>Enable all breakpoints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L105-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.disable" href="#JuliaInterpreter.disable"><code>JuliaInterpreter.disable</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">disable(bp::BreakpointRef)</code></pre><p>Disable breakpoint <code>bp</code>. Disabled breakpoints can be re-enabled with <a href="#JuliaInterpreter.enable"><code>enable</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L86-L90">source</a><div><div><pre><code class="language-none">disable()</code></pre><p>Disable all breakpoints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L112-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.remove" href="#JuliaInterpreter.remove"><code>JuliaInterpreter.remove</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">remove(bp::BreakpointRef)</code></pre><p>Remove (delete) breakpoint <code>bp</code>. Removed breakpoints cannot be re-enabled.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L93-L97">source</a><div><div><pre><code class="language-none">remove()</code></pre><p>Remove all breakpoints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L119-L123">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.break_on" href="#JuliaInterpreter.break_on"><code>JuliaInterpreter.break_on</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">break_on(states...)</code></pre><p>Turn on automatic breakpoints when any of the conditions described in <code>states</code> occurs. The supported states are:</p><ul><li><code>:error</code>: trigger a breakpoint any time an uncaught exception is thrown</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L132-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.break_off" href="#JuliaInterpreter.break_off"><code>JuliaInterpreter.break_off</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">break_off(states...)</code></pre><p>Turn off automatic breakpoints when any of the conditions described in <code>states</code> occurs. See <a href="#JuliaInterpreter.break_on"><code>break_on</code></a> for a description of valid states.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/breakpoints.jl#L150-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.dummy_breakpoint" href="#JuliaInterpreter.dummy_breakpoint"><code>JuliaInterpreter.dummy_breakpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bpref = dummy_breakpoint(recurse, frame::Frame, istoplevel)</code></pre><p>Return a fake breakpoint. <code>dummy_breakpoint</code> can be useful as the <code>recurse</code> argument to <code>evaluate_call!</code> (or any of the higher-order commands) to ensure that you return immediately after stepping into a call.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/commands.jl#L35-L41">source</a></section><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Frame" href="#JuliaInterpreter.Frame"><code>JuliaInterpreter.Frame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Frame</code> represents the current execution state in a particular call frame. Fields:</p><ul><li><code>framecode</code>: the [<code>FrameCode</code>] for this frame</li><li><code>framedata</code>: the [<code>FrameData</code>] for this frame</li><li><code>pc</code>: the program counter (integer index of the next statment to be evaluated) for this frame</li><li><code>caller</code>: the parent caller of this frame, or <code>nothing</code></li><li><code>callee</code>: the frame called by this one, or <code>nothing</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L136-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.FrameCode" href="#JuliaInterpreter.FrameCode"><code>JuliaInterpreter.FrameCode</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>FrameCode</code> holds static information about a method or toplevel code. One <code>FrameCode</code> can be shared by many calling <code>Frame</code>s.</p><p>Important fields:</p><ul><li><code>scope</code>: the <code>Method</code> or <code>Module</code> in which this frame is to be evaluated</li><li><code>src</code>: the <code>CodeInfo</code> object storing (optimized) lowered source code</li><li><code>methodtables</code>: a vector, each entry potentially stores a &quot;local method table&quot; for the corresponding <code>:call</code> expression in <code>src</code> (undefined entries correspond to statements that do not contain <code>:call</code> expressions)</li><li><code>used</code>: a <code>BitSet</code> storing the list of SSAValues that get referenced by later statements.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L46-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.FrameData" href="#JuliaInterpreter.FrameData"><code>JuliaInterpreter.FrameData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>FrameData</code> holds the arguments, local variables, and intermediate execution state in a particular call frame.</p><p>Important fields:</p><ul><li><code>locals</code>: a vector containing the input arguments and named local variables for this frame. The indexing corresponds to the names in the <code>slotnames</code> of the src. Use <a href="#JuliaInterpreter.locals"><code>locals</code></a> to extract the current value of local variables.</li><li><code>ssavalues</code>: a vector containing the <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment</a> values produced at the current state of execution</li><li><code>sparams</code>: the static type parameters, e.g., for <code>f(x::Vector{T}) where T</code> this would store the value of <code>T</code> given the particular input <code>x</code>.</li><li><code>exception_frames</code>: a list of indexes to <code>catch</code> blocks for handling exceptions within the current frame. The active handler is the last one on the list.</li><li><code>last_exception</code>: the exception <code>throw</code>n by this frame or one of its callees.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L106-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.FrameInstance" href="#JuliaInterpreter.FrameInstance"><code>JuliaInterpreter.FrameInstance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>FrameInstance</code> represents a method specialized for particular argument types.</p><p>Fields:</p><ul><li><code>framecode</code>: the <a href="#JuliaInterpreter.FrameCode"><code>FrameCode</code></a> for the method</li><li><code>sparam_vals</code>: the static parameter values for the method</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L90-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.BreakpointState" href="#JuliaInterpreter.BreakpointState"><code>JuliaInterpreter.BreakpointState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BreakpointState(isactive=true, condition=JuliaInterpreter.truecondition)</code></pre><p><code>BreakpointState</code> represents a breakpoint at a particular statement in a <code>FrameCode</code>. <code>isactive</code> indicates whether the breakpoint is currently <a href="#JuliaInterpreter.enable"><code>enable</code></a>d or <a href="#JuliaInterpreter.disable"><code>disable</code></a>d. <code>condition</code> is a function that accepts a single <code>Frame</code>, and <code>condition(frame)</code> must return either <code>true</code> or <code>false</code>. Execution will stop at a breakpoint only if <code>isactive</code> and <code>condition(frame)</code> both evaluate as <code>true</code>. The default <code>condition</code> always returns <code>true</code>.</p><p>To create these objects, see <a href="#JuliaInterpreter.breakpoint"><code>breakpoint</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L19-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.BreakpointRef" href="#JuliaInterpreter.BreakpointRef"><code>JuliaInterpreter.BreakpointRef</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BreakpointRef(framecode, stmtidx)
BreakpointRef(framecode, stmtidx, err)</code></pre><p>A reference to a breakpoint at a particular statement index <code>stmtidx</code> in <code>framecode</code>. If the break was due to an error, supply that as well.</p><p>Commands that execute complex control-flow (e.g., <code>next_line!</code>) may also return a <code>BreakpointRef</code> to indicate that the execution stack switched frames, even when no breakpoint has been set at the corresponding statement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L218-L228">source</a></section><h2><a class="nav-anchor" id="Internal-storage-1" href="#Internal-storage-1">Internal storage</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.framedict" href="#JuliaInterpreter.framedict"><code>JuliaInterpreter.framedict</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>framedict[method]</code> returns the <code>FrameCode</code> for <code>method</code>. For <code>@generated</code> methods, see <a href="#JuliaInterpreter.genframedict"><code>genframedict</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.genframedict" href="#JuliaInterpreter.genframedict"><code>JuliaInterpreter.genframedict</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>genframedict[(method,argtypes)]</code> returns the <code>FrameCode</code> for a <code>@generated</code> method <code>method</code>, for the particular argument types <code>argtypes</code>.</p><p>The framecodes stored in <code>genframedict</code> are for the code returned by the generator (i.e, what will run when you call the method on particular argument types); for the generator itself, its framecode would be stored in <a href="#JuliaInterpreter.framedict"><code>framedict</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L7-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.compiled_methods" href="#JuliaInterpreter.compiled_methods"><code>JuliaInterpreter.compiled_methods</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p><code>meth ∈ compiled_methods</code> indicates that <code>meth</code> should be run using <a href="#JuliaInterpreter.Compiled"><code>Compiled</code></a> rather than recursed into via the interpreter.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/construct.jl#L17-L20">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.@lookup" href="#JuliaInterpreter.@lookup"><code>JuliaInterpreter.@lookup</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">rhs = @lookup(frame, node)
rhs = @lookup(mod, frame, node)</code></pre><p>This macro looks up previously-computed values referenced as SSAValues, SlotNumbers, GlobalRefs, QuoteNode, sparam or exception reference expression. It will also lookup symbols in <code>moduleof(frame)</code>; this can be supplied ahead-of-time via the 3-argument version. If none of the above apply, the value of <code>node</code> will be returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/interpret.jl#L32-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.is_wrapper_call" href="#JuliaInterpreter.is_wrapper_call"><code>JuliaInterpreter.is_wrapper_call</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Determine whether we are calling a function for which the current function is a wrapper (either because of optional arguments or because of keyword arguments).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L115-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.is_doc_expr" href="#JuliaInterpreter.is_doc_expr"><code>JuliaInterpreter.is_doc_expr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_doc_expr(ex)</code></pre><p>Test whether expression <code>ex</code> is a <code>@doc</code> expression.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L128-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.is_global_ref" href="#JuliaInterpreter.is_global_ref"><code>JuliaInterpreter.is_global_ref</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_global_ref(g, mod, name)</code></pre><p>Tests whether <code>g</code> is equal to <code>GlobalRef(mod, name)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L80-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CodeTracking.whereis" href="#CodeTracking.whereis"><code>CodeTracking.whereis</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">loc = whereis(frame, pc=frame.pc)</code></pre><p>Return the file and line number for <code>frame</code> at <code>pc</code>.  If this cannot be determined, <code>loc == nothing</code>. Otherwise <code>loc == (filepath, line)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L175-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.linenumber" href="#JuliaInterpreter.linenumber"><code>JuliaInterpreter.linenumber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">line = linenumber(framecode, pc)</code></pre><p>Return the &quot;static&quot; line number at statement index <code>pc</code>. The static line number is the location at the time the method was most recently defined. See <a href="#CodeTracking.whereis"><code>CodeTracking.whereis</code></a> for dynamic line information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L190-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.statementnumber" href="#JuliaInterpreter.statementnumber"><code>JuliaInterpreter.statementnumber</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">stmtidx = statementnumber(frame, line)</code></pre><p>Return the index of the first statement in <code>frame</code>&#39;s <code>CodeInfo</code> that corresponds to static line number <code>line</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L220-L225">source</a><div><div><pre><code class="language-none">framecode, stmtidx = statementnumber(method, line)</code></pre><p>Return the index of the first statement in <code>framecode</code> that corresponds to the given static line number <code>line</code> in <code>method</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L233-L238">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.Variable" href="#JuliaInterpreter.Variable"><code>JuliaInterpreter.Variable</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><code>Variable</code> is a struct representing a variable with an asigned value. By calling the function <code>locals</code>[@ref] on a <code>Frame</code>[@ref] a <code>Vector</code> of <code>Variable</code>&#39;s is returned.</p><p>Important fields:</p><ul><li><code>value::Any</code>: the value of the local variable</li><li><code>name::Symbol</code>: the name of the variable as given in the source code</li><li><code>isparam::Bool</code>: if the variable is a type parameter, for example <code>T</code> in <code>f(x::T) where {T} = x</code> .</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/types.jl#L196-L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.locals" href="#JuliaInterpreter.locals"><code>JuliaInterpreter.locals</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">local_variables = locals(frame::Frame)::Vector{Variable}</code></pre><p>Return the local variables as a vector of <code>Variable</code>[@ref].</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L287-L291">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaInterpreter.whichtt" href="#JuliaInterpreter.whichtt"><code>JuliaInterpreter.whichtt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">method = whichtt(tt)</code></pre><p>Like <code>which</code> except it operates on the complete tuple-type <code>tt</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/77fc178a75bc8af8267fc6567dcd95b26d59c63b/src/utils.jl#L28-L32">source</a></section><footer><hr/><a class="previous" href="../internals/"><span class="direction">Previous</span><span class="title">Internals</span></a></footer></article></body></html>
